# AOC 2019
I skipped some of the later int-code machine puzzles and maybe some others in later days. This will be all the int-code parts plus anything else I skipped

* Day 2: This was the first int-code machine puzzle. They started earlier than I remembered. I am doing each of these in Python and then in Rust
* Day 5: This is the next day with the int-code machine. Already I remember why I was not super happy about these. I had to rewrite a good bit to better accommodate input and output. Add to that the new instructions and it is a good bit of code to have for an early day
* Day 7 (Python): Another int-code day and we will have to rewrite how my machine handles input and output some more to be able to handle this puzzle. It will need an automated way for the input to come in and a way to take action on output. Part 1 is done, but part 2 will need changes to the int-code machine to be able to hold its state between runs if needed and, maybe, to hand back control to the caller after each output. The machine changes needed are going to break previous operation, but hopefully will be OK for future days
* Day 7 (Rust): Because I needed to refactor the running state and input and output, this changed all the tests. The rust version ended up with a lot of tests already, so many changes were needed just to get the old testing to run again.  
Next Rust choice, where to put the amplifier? I don't remember if the amplifier is a one-off that just uses the int-code machine, but I am going to assume that it is and put it with the day07 project and tests for it just in that day and not with the overall int-code machine. After some value passing rework, tests for part one where running. I then had some debug to terminal connection issues in VS Code that seemed a little random, but after some terminal restarts and debug server restart, part one ran and was correct. Part two only needed a slightly different run function and tests and puzzle output were good.
* Day 9 (Python): Things are not going to be backward compatible between days as too much of the int-code machine is changing to meet new input/output needs. Also testing is changing a lot from day-to-day in the Python version. With the new "relative base" modes and with adding some checks, the machine code is getting pretty long. Testing should also get pretty long if I want to try to catch all cases, but we will see if I actually do that. 2019 is an exercise in the power of a good initial set of requirements.  
After completing the "relative base" changes for all instructions and getting all the day09 tests to run, I ran part 1. I had three errors all due to implementing writing to an address with "relative base" incorrectly. After that, part1 and part2 ran fine. I did not put in additional testing
* Day 9 (Rust): Much rewriting of both the int-code computer and the tests, but quick after that for both parts
* Day 13 (Python): Skipping day 11 as it does not have any int-code machine updates and I was not missing stars for that one. This will start the days where I can collect missed stars. Redid part 1 and then did part 2 to collect one of the stars I missed earlier. Once I had the game set up, I tried to move the joy-stick as the ball moved. This was getting pretty full of cases and long on code. I then had the idea to just copy the machine after each successful paddle bounce and let the ball go until it met the line above the paddle line. I then would pass that back to the main machine (and dump the copy) so I would alway know where the paddle would have to be next and could go to that position directly. I checked in a copy, but will try to add an animation  
**Update** Added the animation, but it is very hacky and slow (like, a minute)  
[![Watch the animation](https://img.youtube.com/vi/ZwmkmtoP39s/0.jpg)](https://www.youtube.com/watch?v=ZwmkmtoP39s)
* Day 13 (Rust): Part 1 took 1.1 ms and part 2 took 77.6 ms. I used the same approach as with Python, but no printing or visualization and since I knew what to do I could cut out some work. The main trouble was workspace/toolchain issues. I was doing this part on another machine and was suffering from VS Code toolchain issues with rust and how I had it set up. After hours of trying to get AI help, I found a good-old StackOverflow post that got things into an OK setup. From there it was not too bad to get the correct result with a run that had an OK time. I wanted to use an array of small i8s, but ended up using a nested Vec<Vec<i64>> to get around indexing issues and casting requirements (just easier). I may return later and see if I can get a version to work like this, but done for now
* Day 14 (Python): This one took a bit of time. It does not work with a depth-first expansion. I eventually fixed some errors and got a breath-first expansion to work and was very grateful for all the example inputs. For a first pass, I just let part 2 run for 25 minutes. I will update with a caching version that I hope greatly cuts down run time  
**UPDATE** It was running slower instead of faster. I realized I had the ORE count in what I was passing to my cached function. However, it's still slow and using too much memory to finish. Next try is just caching the result using remainders from the initial 1 FUEL state and that runs faster, but wrong answer. I had the wrong conversion to a frozenset. Still slower. There are just too many remainders with too many states to get any cache hits, so all I am doing is slowing it down. There is probably a way to slice the state changes to either cache effectively or catch repeating sequences. However, I have both stars and am moving on
* Day 14 (Rust): I think I will do this a couple ways. First is part 1 similar to the Python version with HashMaps. Part 2 running the same slow counting method as Python ran in just under 3 minutes or about 8x faster than the Python version. After reading a Python solution using binary search for the fuel amount, I put that into a Rust part 2. Now part 2 is 890 micro seconds or ~28,000x faster than the Python version. Could it be just a bit faster with Vecs instead of HashMaps? Yes, it is. I made a v2 and part 2 now runs in ~399 micro seconds, ~60,000x faster than Python
* Day 15 (Python) Part 1 is done (I have the star) and kinda working. However, it does not seem very efficient and is stopping in an unexpected location. This is causing it to not explore the entire map and therefor can't really be used for part 2. I think it is fixable in a similar way to day 13, but will do a check-in first.  
Part 2 I copied the vm and the current location to explore in each direction and pushed new, valid moves on a list to further explore. This worked, but was super slow. All the deepcopies of the int-code machines is probably the issue. I put a LOT of free space at the end of programs, which is fine for one, but in this case I would guess a couple GB of slow copies. I could reduce the copies I need by doing the local directional search without making copies. Then I could reduce the space I add at the end by 90%. Those two would probably get a 20x speed-up, but again I will just move on to a Rust version
* Day 15 (Rust) Since I already knew how to do it, it was easier. I still used some clones (copies) of the VM in this solution, but since I both put far less padding (memory space) in the VM for the Rust version and it is just data in the Rust version instead of a series of objects, it is much faster. Python took a few minutes and Rust took about 37 ms for both parts
* Day 17 (Python) Part one was pretty clean, but part two was a bit of a mess. There is a lot of translation out of and into ASCII and an assumption that the 'y' or 'n' is ASCII and there is still output if you choose 'n'. That is on top of having to get a working set of three programs. I started that by just looking, but my input seemed to have too many options to do manually, so I generated possibilities assuming the first few commands in one program and the last few in another. Then generated a lot of middle programs, filtered them with an assumption of starting A,B,C and then tried them all. Then, none of the solutions that left me on the correct end position worked. Seems like my starts with A,B,C assumption does not traverse all parts of the scaffolding.  
Going to try a different approach. There is an obvious path of just keep going straight until you must turn. Let's see if that can be compressed to a working set of three sub-programs. No, I can output this path, but there are too many Rs at the beginning to get the correct Ls in the middle and end. There are two loops early in the path that could be traversed clockwise or counter-clockwise that would not lengthen the total path much. Let's manually see if one of those will work.  
OK, back to the fact that my input has too many options to just manually walk it through. New attempt will be to load into NetworkX all the options where there is a mandatory or optional turn. Then I will have that give all paths not longer than the requirement lengths would allow. Then look for three sub-sets in each that would match everything (or go back to the original effort without the A,B,C assumption)  
Turns out I should have stuck with the "go forward until you have to turn" and just tried a shorter A program with manual assembly of each part. This worked... eventually.
Again, not going to clean up the Python. Just going to take my many things learned to the Rust solution.
* Day 17 (Rust) The part 2 function is a little long and not as DRY as it could be. However, I did a programmatic search for the part 2 answer here instead of just feeding in the manual one. I didn't time it, but seemed sub-second in debug. Learned a way to shift to ASCII in Rust. You can say b'A' to get the byte version of A which is its ASCII encoding
* Day 19 (Python) So the intcode program will not take repeated inputs, just one set of x and y. It took some time to figure that out and then copying the machine took a long time (I put 1M ints at the end). So I just reduced that amount to 100K so it would run within a minute. With the first star in-hand I modified again down to 10K and printed out the 50x50 area so I could see it. The expansion is a little weird as the beam seems to get a little narrower after stepping wider. However, maybe a quick estimate can get us close the the start and then we can run from there? The X position of the width is shifting just faster than 1 per y, so I will try values to see if I can get to about 200 wide before I start a programmatic counting. This works and after a bit of off-by-one issue and a lot of run time (almost 8 min) I have the star for part 2. Even though it takes a bit of time, I might keep the general approach for the Rust version
* Day 19 (Rust) Did part 1 the same way as I did with Python and it ran in 75.1 ms. Going to try adding a function to my intcode machine to move the execution pointer so that I can try getting rid of the `clone`. This does not work and since I don't want to reverse engineer the intcode program or track the state changes to reset it, I will just put it back the way it was.  
Part 2: Since I timed part 1 and know how far I need to go, I could do a total brute force in about 2 minutes. However, let's take the exact same shortcut that I used in the Python version to start with and compare with that. That takes about 4.3 seconds. Next let's try a couple improvements. We can stop each line when we get to the 0 after the 1s. We can start each line one step later for x as we know it moves that way at least one per y. Last, we don't need the hash map and can use a vector instead. With all three of these improvements the runtime is 1.3 seconds for part 2
* Day 21 (Python) After reading this day and talking with someone, I was thinking this would be a boolean logic puzzle that would require some advanced instruction compression techniques. I was not super keen on trying to engineer these from scratch (the person I was talking to was a compiler software dev) so I figured I would see how far the LLMs have come along. First I got my Python running the example program and printing the output, then I asked the free, Genini 3 (2026/02/13) to give me the "springscript" as I could get it from there to the intcode machine. I gave it most of the puzzle minus some of the start and end it should not need. It took five minutes, but then gave something valid to try that worked.  
Will part 2 be too tricky for the LLM? No, it gave another working "springscript" and it didn't need any advanced tricks to overcome the instruction count limit. Hmm... I asked the other person for their input and took the LLM up on the offer to explain the logic compression that might be needed for more complex inputs. It referenced the same thing the other person mentioned and did a good job explaining it. It also worked on the other person's input. I probably should have stuck with trying to figure this one out  
Since this was more than two years old, did the LLM really figure this out or was it just parsing someone else's explanation? I don't know. If humans had not already well described De Morganâ€™s Laws could it have come up with them? I don't know, but it didn't have to. Still quite nice and very useful even if just a summary of previous work.
* Day 21 (Rust) ...